'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@craftjs/utils');
var React = require('react');
var invariant = require('tiny-invariant');
var immer = require('immer');
var shortid = require('shortid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);
var shortid__default = /*#__PURE__*/_interopDefaultLegacy(shortid);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
}

var EventHandlerContext = React.createContext(null);
var useEventHandler = function () { return React.useContext(EventHandlerContext); };

var defineEventListener = function (name, handler, capture) { return [name, handler, capture]; };
/**
 * Check if a specified event is blocked by a child
 * that's a descendant of the specified element
 */
var isEventBlockedByDescendant = function (e, eventName, el) {
    // TODO: Update TS to use optional chaining
    var blockingElements = (e.craft && e.craft.blockedEvents[eventName]) || [];
    for (var i = 0; i < blockingElements.length; i++) {
        var blockingElement = blockingElements[i];
        if (el !== blockingElement && el.contains(blockingElement)) {
            return true;
        }
    }
    return false;
};
/**
 * Attaches/detaches a Handler to a DOM element
 * The handler is attached/detached depending on the enabled state from the `store`
 */
var WatchHandler = /** @class */ (function () {
    function WatchHandler(store, el, opts, handler) {
        var _this = this;
        this.el = el;
        this.opts = opts;
        this.handler = handler;
        this.unsubscribe = store.subscribe(function (state) { return ({ enabled: state.options.enabled }); }, function (_a) {
            var enabled = _a.enabled;
            if (!document.body.contains(el)) {
                _this.remove();
                return _this.unsubscribe();
            }
            if (enabled) {
                _this.add();
            }
            else {
                _this.remove();
            }
        }, true);
    }
    WatchHandler.prototype.add = function () {
        var _this = this;
        var _a = this.handler, init = _a.init, events = _a.events;
        this.cleanDOM = init && init(this.el, this.opts);
        this.listenersToRemove =
            events &&
                events.map(function (_a) {
                    var eventName = _a[0], listener = _a[1], capture = _a[2];
                    var bindedListener = function (e) {
                        // Store initial Craft event value
                        if (!e.craft) {
                            e.craft = {
                                blockedEvents: {},
                                stopPropagation: function () { },
                            };
                        }
                        if (!isEventBlockedByDescendant(e, eventName, _this.el)) {
                            e.craft.stopPropagation = function () {
                                if (!e.craft.blockedEvents[eventName]) {
                                    e.craft.blockedEvents[eventName] = [];
                                }
                                e.craft.blockedEvents[eventName].push(_this.el);
                            };
                            listener(e, _this.opts);
                        }
                    };
                    _this.el.addEventListener(eventName, bindedListener, capture);
                    return function () {
                        return _this.el.removeEventListener(eventName, bindedListener, capture);
                    };
                });
    };
    WatchHandler.prototype.remove = function () {
        if (this.cleanDOM) {
            this.cleanDOM();
            this.cleanDOM = null;
        }
        if (this.listenersToRemove) {
            this.listenersToRemove.forEach(function (l) { return l(); });
            this.listenersToRemove = null;
        }
    };
    return WatchHandler;
}());
/**
 * Creates Event Handlers
 */
var Handlers = /** @class */ (function () {
    function Handlers(store) {
        // Stores a map of DOM elements to their attached connector's WatchHandler
        this.wm = new WeakMap();
        this.store = store;
    }
    // Returns ref connectors for handlers
    Handlers.prototype.connectors = function () {
        var _this = this;
        var initialHandlers = this.handlers() || {};
        return Object.keys(initialHandlers).reduce(function (accum, key) {
            var _a = initialHandlers[key], init = _a.init, events = _a.events;
            if (!init && !events) {
                accum[key] = function () { };
                return accum;
            }
            var connector = function (el, opts) {
                var _a;
                if (!el || !document.body.contains(el)) {
                    _this.wm.delete(el);
                    return;
                }
                var domHandler = _this.wm.get(el);
                if (domHandler && domHandler[key]) {
                    return;
                }
                _this.wm.set(el, _assign(_assign({}, domHandler), (_a = {}, _a[key] = new WatchHandler(_this.store, el, opts, {
                    init: init,
                    events: events,
                }), _a)));
            };
            accum[key] = utils.wrapHookToRecognizeElement(connector);
            return accum;
        }, {});
    };
    Handlers.getConnectors = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var that = new (this.bind.apply(this, __spreadArrays([void 0], args)))();
        return that.connectors();
    };
    return Handlers;
}());

/**
 * Craft's core event handlers
 * Connectors are created from the handlers defined here
 */
var CoreEventHandlers = /** @class */ (function (_super) {
    __extends(CoreEventHandlers, _super);
    function CoreEventHandlers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new instance of Handlers with reference to the current EventHandlers
     * @param type A class that extends DerivedEventHandlers
     * @param args Additional arguments to pass to the constructor
     */
    CoreEventHandlers.prototype.derive = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new (type.bind.apply(type, __spreadArrays([void 0, this.store, this], args)))();
    };
    return CoreEventHandlers;
}(Handlers));
/**
 *  Allows for external packages to easily extend and derive the CoreEventHandlers
 */
var DerivedEventHandlers = /** @class */ (function (_super) {
    __extends(DerivedEventHandlers, _super);
    function DerivedEventHandlers(store, derived) {
        var _this = _super.call(this, store) || this;
        _this.derived = derived;
        return _this;
    }
    return DerivedEventHandlers;
}(Handlers));

var createShadow = function (e) {
    var shadow = e.target.cloneNode(true);
    var _a = e.target.getBoundingClientRect(), width = _a.width, height = _a.height;
    shadow.style.width = width + "px";
    shadow.style.height = height + "px";
    shadow.style.position = 'fixed';
    shadow.style.left = '-100%';
    shadow.style.top = '-100%';
    document.body.appendChild(shadow);
    e.dataTransfer.setDragImage(shadow, 0, 0);
    return shadow;
};

/**
 * Specifies Editor-wide event handlers and connectors
 */
var DefaultEventHandlers = /** @class */ (function (_super) {
    __extends(DefaultEventHandlers, _super);
    function DefaultEventHandlers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Safely run handler if Node Id exists
    DefaultEventHandlers.prototype.defineNodeEventListener = function (eventName, handler, capture) {
        var _this = this;
        return defineEventListener(eventName, function (e, id) {
            if (id) {
                var node = _this.store.query.node(id).get();
                if (!node) {
                    return;
                }
            }
            handler(e, id);
        }, capture);
    };
    DefaultEventHandlers.prototype.handlers = function () {
        var _this = this;
        return {
            select: {
                init: function () { return function () { return _this.store.actions.setNodeEvent('selected', null); }; },
                events: [
                    this.defineNodeEventListener('mousedown', function (e, id) {
                        e.craft.stopPropagation();
                        _this.store.actions.setNodeEvent('selected', id);
                    }),
                ],
            },
            hover: {
                init: function () { return function () { return _this.store.actions.setNodeEvent('hovered', null); }; },
                events: [
                    this.defineNodeEventListener('mouseover', function (e, id) {
                        e.craft.stopPropagation();
                        _this.store.actions.setNodeEvent('hovered', id);
                    }),
                ],
            },
            drop: {
                events: [
                    defineEventListener('dragover', function (e) {
                        e.craft.stopPropagation();
                        e.preventDefault();
                    }),
                    this.defineNodeEventListener('dragenter', function (e, targetId) {
                        e.craft.stopPropagation();
                        e.preventDefault();
                        var draggedElement = DefaultEventHandlers.draggedElement;
                        if (!draggedElement) {
                            return;
                        }
                        var node = draggedElement;
                        if (draggedElement.rootNodeId) {
                            var nodeTree = draggedElement;
                            node = nodeTree.nodes[nodeTree.rootNodeId];
                        }
                        var x = e.clientX, y = e.clientY;
                        var indicator = _this.store.query.getDropPlaceholder(node, targetId, { x: x, y: y });
                        if (!indicator) {
                            return;
                        }
                        _this.store.actions.setIndicator(indicator);
                        DefaultEventHandlers.indicator = indicator;
                    }),
                ],
            },
            drag: {
                init: function (el, id) {
                    if (!_this.store.query.node(id).isDraggable()) {
                        return function () { };
                    }
                    el.setAttribute('draggable', 'true');
                    return function () { return el.setAttribute('draggable', 'false'); };
                },
                events: [
                    this.defineNodeEventListener('dragstart', function (e, id) {
                        e.craft.stopPropagation();
                        _this.store.actions.setNodeEvent('dragged', id);
                        DefaultEventHandlers.draggedElementShadow = createShadow(e);
                        DefaultEventHandlers.draggedElement = id;
                    }),
                    defineEventListener('dragend', function (e) {
                        e.craft.stopPropagation();
                        var onDropElement = function (draggedElement, placement) {
                            var index = placement.index + (placement.where === 'after' ? 1 : 0);
                            _this.store.actions.move(draggedElement, placement.parent.id, index);
                        };
                        _this.dropElement(onDropElement);
                    }),
                ],
            },
            create: {
                init: function (el) {
                    el.setAttribute('draggable', 'true');
                    return function () { return el.removeAttribute('draggable'); };
                },
                events: [
                    defineEventListener('dragstart', function (e, userElement) {
                        e.craft.stopPropagation();
                        var tree = _this.store.query
                            .parseReactElement(userElement)
                            .toNodeTree();
                        DefaultEventHandlers.draggedElementShadow = createShadow(e);
                        DefaultEventHandlers.draggedElement = tree;
                    }),
                    defineEventListener('dragend', function (e) {
                        e.craft.stopPropagation();
                        var onDropElement = function (draggedElement, placement) {
                            var index = placement.index + (placement.where === 'after' ? 1 : 0);
                            _this.store.actions.addNodeTree(draggedElement, placement.parent.id, index);
                        };
                        _this.dropElement(onDropElement);
                    }),
                ],
            },
        };
    };
    DefaultEventHandlers.prototype.dropElement = function (onDropNode) {
        var draggedElement = DefaultEventHandlers.draggedElement, draggedElementShadow = DefaultEventHandlers.draggedElementShadow, indicator = DefaultEventHandlers.indicator;
        if (draggedElement && indicator && !indicator.error) {
            var placement = indicator.placement;
            onDropNode(draggedElement, placement);
        }
        if (draggedElementShadow) {
            draggedElementShadow.parentNode.removeChild(draggedElementShadow);
            DefaultEventHandlers.draggedElementShadow = null;
        }
        DefaultEventHandlers.draggedElement = null;
        DefaultEventHandlers.indicator = null;
        this.store.actions.setIndicator(null);
        this.store.actions.setNodeEvent('dragged', null);
    };
    DefaultEventHandlers.indicator = null;
    return DefaultEventHandlers;
}(CoreEventHandlers));

function movePlaceholder(pos, canvasDOMInfo, // which canvas is cursor at
bestTargetDomInfo // closest element in canvas (null if canvas is empty)
) {
    var t = 0, l = 0, w = 0, h = 0, where = pos.where;
    var elDim = bestTargetDomInfo;
    if (elDim) {
        // If it's not in flow (like 'float' element)
        if (!elDim.inFlow) {
            w = 2;
            h = elDim.outerHeight;
            t = elDim.top;
            l = where === 'before' ? elDim.left : elDim.left + elDim.outerWidth;
        }
        else {
            w = elDim.outerWidth;
            h = 2;
            t = where === 'before' ? elDim.top : elDim.bottom;
            l = elDim.left;
        }
    }
    else {
        if (canvasDOMInfo) {
            t = canvasDOMInfo.top + canvasDOMInfo.padding.top;
            l = canvasDOMInfo.left + canvasDOMInfo.padding.left;
            w =
                canvasDOMInfo.outerWidth -
                    canvasDOMInfo.padding.right -
                    canvasDOMInfo.padding.left -
                    canvasDOMInfo.margin.left -
                    canvasDOMInfo.margin.right;
            h = 2;
        }
    }
    return {
        top: t + "px",
        left: l + "px",
        width: w + "px",
        height: h + "px",
    };
}

var EditorContext = React.createContext({});

function useInternalEditor(collector) {
    var handlers = useEventHandler();
    var store = React.useContext(EditorContext);
    var collected = utils.useCollector(store, collector);
    var connectors = React.useMemo(function () { return handlers && handlers.connectors(); }, [
        handlers,
    ]);
    return _assign(_assign({}, collected), { connectors: connectors || {}, inContext: !!store, store: store });
}

var Events = function (_a) {
    var children = _a.children;
    var _b = useInternalEditor(function (state) { return ({
        indicator: state.events.indicator,
        indicatorOptions: state.options.indicator,
        handlers: state.handlers,
        handlersFactory: state.options.handlers,
    }); }), actions = _b.actions, indicator = _b.indicator, indicatorOptions = _b.indicatorOptions, store = _b.store, handlers = _b.handlers, handlersFactory = _b.handlersFactory;
    var storeRef = React.useRef(store);
    storeRef.current = store;
    React.useEffect(function () {
        // TODO: Let's use setState for all internal actions
        actions.history
            .ignore()
            .setState(function (state) { return (state.handlers = handlersFactory(storeRef.current)); });
    }, [actions, handlersFactory]);
    return handlers ? (React__default['default'].createElement(EventHandlerContext.Provider, { value: handlers },
        indicator &&
            React__default['default'].createElement(utils.RenderIndicator, {
                style: _assign(_assign({}, movePlaceholder(indicator.placement, utils.getDOMInfo(indicator.placement.parent.dom), indicator.placement.currentNode &&
                    utils.getDOMInfo(indicator.placement.currentNode.dom))), { backgroundColor: indicator.error
                        ? indicatorOptions.error
                        : indicatorOptions.success, transition: '0.2s ease-in' }),
            }),
        children)) : null;
};

/**
 * Creates Node-specific event handlers and connectors
 */
var NodeHandlers = /** @class */ (function (_super) {
    __extends(NodeHandlers, _super);
    function NodeHandlers(store, derived, nodeId) {
        var _this = _super.call(this, store, derived) || this;
        _this.id = nodeId;
        return _this;
    }
    NodeHandlers.prototype.handlers = function () {
        var _this = this;
        var parentConnectors = this.derived.connectors();
        return {
            connect: {
                init: function (el) {
                    parentConnectors.select(el, _this.id);
                    parentConnectors.hover(el, _this.id);
                    parentConnectors.drop(el, _this.id);
                    _this.store.actions.setDOM(_this.id, el);
                },
            },
            drag: {
                init: function (el) {
                    parentConnectors.drag(el, _this.id);
                },
            },
        };
    };
    return NodeHandlers;
}(DerivedEventHandlers));

var NodeContext = React__default['default'].createContext(null);
var NodeProvider = function (_a) {
    var id = _a.id, _b = _a.related, related = _b === void 0 ? false : _b, children = _a.children;
    var handlers = useEventHandler();
    var hydrationTimestamp = useInternalEditor(function (state) { return ({
        hydrationTimestamp: state.nodes[id] && state.nodes[id]._hydrationTimestamp,
    }); }).hydrationTimestamp;
    // Get fresh connectors whenever the Nodes are rehydrated (eg: after deserialisation)
    var connectors = React.useMemo(function () {
        return handlers.derive(NodeHandlers, id).connectors();
        // eslint-disable-next-line  react-hooks/exhaustive-deps
    }, [handlers, hydrationTimestamp, id]);
    return (React__default['default'].createElement(NodeContext.Provider, { value: { id: id, related: related, connectors: connectors } }, children));
};

function useInternalNode(collect) {
    var context = React.useContext(NodeContext);
    var id = context.id, related = context.related, connectors = context.connectors;
    var _a = useInternalEditor(function (state) { return id && state.nodes[id] && collect && collect(state.nodes[id]); }), EditorActions = _a.actions, query = _a.query, collected = __rest(_a, ["actions", "query"]);
    var actions = React.useMemo(function () {
        return {
            setProp: function (cb, throttleRate) {
                if (throttleRate) {
                    EditorActions.history.throttle(throttleRate).setProp(id, cb);
                }
                else {
                    EditorActions.setProp(id, cb);
                }
            },
            setCustom: function (cb, throttleRate) {
                if (throttleRate) {
                    EditorActions.history.throttle(throttleRate).setCustom(id, cb);
                }
                else {
                    EditorActions.setCustom(id, cb);
                }
            },
            setHidden: function (bool) { return EditorActions.setHidden(id, bool); },
        };
    }, [EditorActions, id]);
    return _assign(_assign({}, collected), { id: id,
        related: related, inNodeContext: !!context, actions: actions,
        connectors: connectors });
}

/**
 * A Hook to that provides methods and state information related to the corresponding Node that manages the current component.
 * @param collect - Collector function to consume values from the corresponding Node's state
 */
function useNode(collect) {
    var _a = useInternalNode(collect), id = _a.id, related = _a.related, actions = _a.actions, inNodeContext = _a.inNodeContext, connectors = _a.connectors, collected = __rest(_a, ["id", "related", "actions", "inNodeContext", "connectors"]);
    return _assign(_assign({}, collected), { actions: actions,
        id: id,
        related: related, setProp: function (cb) {
            utils.deprecationWarning('useNode().setProp()', {
                suggest: 'useNode().actions.setProp()',
            });
            return actions.setProp(cb);
        }, inNodeContext: inNodeContext,
        connectors: connectors });
}

var SimpleElement = function (_a) {
    var render = _a.render;
    var _b = useNode().connectors, connect = _b.connect, drag = _b.drag;
    return typeof render.type === 'string'
        ? connect(drag(React__default['default'].cloneElement(render)))
        : render;
};

var Render = function () {
    var _a = useInternalNode(function (node) { return ({
        type: node.data.type,
        props: node.data.props,
        nodes: node.data.nodes,
        hydrationTimestamp: node._hydrationTimestamp,
    }); }), type = _a.type, props = _a.props, nodes = _a.nodes, hydrationTimestamp = _a.hydrationTimestamp;
    return React.useMemo(function () {
        var children = props.children;
        if (nodes && nodes.length > 0) {
            children = (React__default['default'].createElement(React__default['default'].Fragment, null, nodes.map(function (id) { return (React__default['default'].createElement(NodeElement, { id: id, key: id })); })));
        }
        var render = React__default['default'].createElement(type, props, children);
        if (typeof type == 'string') {
            return React__default['default'].createElement(SimpleElement, { render: render });
        }
        return render;
        // eslint-disable-next-line  react-hooks/exhaustive-deps
    }, [type, props, hydrationTimestamp, nodes]);
};
var RenderNodeToElement = function () {
    var hidden = useInternalNode(function (node) { return ({
        hidden: node.data.hidden,
    }); }).hidden;
    var onRender = useInternalEditor(function (state) { return ({
        onRender: state.options.onRender,
    }); }).onRender;
    // don't display the node since it's hidden
    if (hidden) {
        return null;
    }
    return React__default['default'].createElement(onRender, { render: React__default['default'].createElement(Render, null) });
};

var NodeElement = React__default['default'].memo(function (_a) {
    var id = _a.id;
    return (React__default['default'].createElement(NodeProvider, { id: id },
        React__default['default'].createElement(RenderNodeToElement, null)));
});

var defaultElementProps = {
    is: 'div',
    canvas: false,
    custom: {},
    hidden: false,
};
var elementPropToNodeData = {
    is: 'type',
    canvas: 'isCanvas',
};
function Element(_a) {
    var id = _a.id, children = _a.children, elementProps = __rest(_a, ["id", "children"]);
    var _b = _assign(_assign({}, defaultElementProps), elementProps), is = _b.is, custom = _b.custom, canvas = _b.canvas, otherProps = __rest(_b, ["is", "custom", "canvas"]);
    var _c = useInternalEditor(), query = _c.query, actions = _c.actions;
    var _d = useInternalNode(function (node) { return ({
        node: {
            id: node.id,
            data: node.data,
        },
    }); }), node = _d.node, inNodeContext = _d.inNodeContext;
    var _e = React.useState(null), linkedNodeId = _e[0], setLinkedNodeId = _e[1];
    utils.useEffectOnce(function () {
        invariant__default['default'](!!id, utils.ERROR_TOP_LEVEL_ELEMENT_NO_ID);
        var nodeId = node.id, data = node.data;
        if (inNodeContext) {
            var linkedNodeId_1;
            var existingNode = data.linkedNodes &&
                data.linkedNodes[id] &&
                query.node(data.linkedNodes[id]).get();
            // Render existing linked Node if it already exists (and is the same type as the JSX)
            if (existingNode && existingNode.data.type === is) {
                linkedNodeId_1 = existingNode.id;
                // Merge JSX and existing props
                var mergedProps_1 = _assign(_assign({}, existingNode.data.props), otherProps);
                actions.history
                    .ignore()
                    .setProp(linkedNodeId_1, function (props) {
                    return Object.keys(mergedProps_1).forEach(function (key) { return (props[key] = mergedProps_1[key]); });
                });
            }
            else {
                // otherwise, create and render a new linked Node
                var linkedElement = React__default['default'].createElement(Element, elementProps, children);
                var tree = query.parseReactElement(linkedElement).toNodeTree();
                linkedNodeId_1 = tree.rootNodeId;
                actions.history.ignore().addLinkedNodeFromTree(tree, nodeId, id);
            }
            setLinkedNodeId(linkedNodeId_1);
        }
    });
    return linkedNodeId ? React__default['default'].createElement(NodeElement, { id: linkedNodeId }) : null;
}

var deprecateCanvasComponent = function () {
    return utils.deprecationWarning('<Canvas />', {
        suggest: '<Element canvas={true} />',
    });
};
function Canvas(_a) {
    var props = __rest(_a, []);
    React.useEffect(function () { return deprecateCanvasComponent(); }, []);
    return React__default['default'].createElement(Element, _assign({}, props, { canvas: true }));
}

/**
 * A React Component that defines the editable area
 */
var Frame = function (_a) {
    var children = _a.children, json = _a.json, data = _a.data;
    var _b = useInternalEditor(), actions = _b.actions, query = _b.query;
    var _c = React.useState(null), render = _c[0], setRender = _c[1];
    if (!!json) {
        utils.deprecationWarning('<Frame json={...} />', {
            suggest: '<Frame data={...} />',
        });
    }
    var initialState = React.useRef({
        initialChildren: children,
        initialData: data || json,
    });
    React.useEffect(function () {
        var _a = initialState.current, initialChildren = _a.initialChildren, initialData = _a.initialData;
        if (initialData) {
            actions.history.ignore().deserialize(initialData);
        }
        else if (initialChildren) {
            var rootNode_1 = React__default['default'].Children.only(initialChildren);
            var node = query.parseReactElement(rootNode_1).toNodeTree(function (node, jsx) {
                if (jsx === rootNode_1) {
                    node.id = utils.ROOT_NODE;
                }
                return node;
            });
            actions.history.ignore().addNodeTree(node);
        }
        setRender(React__default['default'].createElement(NodeElement, { id: utils.ROOT_NODE }));
    }, [actions, query]);
    return render;
};

var getPublicActions = function (actions) {
    var addLinkedNodeFromTree = actions.addLinkedNodeFromTree, setDOM = actions.setDOM, setNodeEvent = actions.setNodeEvent, replaceNodes = actions.replaceNodes, reset = actions.reset, EditorActions = __rest(actions, ["addLinkedNodeFromTree", "setDOM", "setNodeEvent", "replaceNodes", "reset"]);
    return EditorActions;
};
function useEditor(collect) {
    var _a = useInternalEditor(collect), connectors = _a.connectors, internalActions = _a.actions, _b = _a.query, deserialize = _b.deserialize, query = __rest(_b, ["deserialize"]), store = _a.store, collected = __rest(_a, ["connectors", "actions", "query", "store"]);
    var EditorActions = getPublicActions(internalActions);
    var actions = React.useMemo(function () {
        return _assign(_assign({}, EditorActions), { history: _assign(_assign({}, EditorActions.history), { ignore: function () {
                    var _a;
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return getPublicActions((_a = EditorActions.history).ignore.apply(_a, args));
                }, throttle: function () {
                    var _a;
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return getPublicActions((_a = EditorActions.history).throttle.apply(_a, args));
                } }) });
    }, [EditorActions]);
    return _assign({ connectors: connectors,
        actions: actions,
        query: query,
        store: store }, collected);
}

function connectEditor(collect) {
    return function (WrappedComponent) {
        return function (props) {
            var Editor = collect ? useEditor(collect) : useEditor();
            return React__default['default'].createElement(WrappedComponent, _assign({}, Editor, props));
        };
    };
}

function connectNode(collect) {
    return function (WrappedComponent) {
        return function (props) {
            var node = useNode(collect);
            return React__default['default'].createElement(WrappedComponent, _assign({}, node, props));
        };
    };
}

var fromEntries = function (pairs) {
    if (Object.fromEntries) {
        return Object.fromEntries(pairs);
    }
    return pairs.reduce(function (accum, _a) {
        var _b;
        var id = _a[0], value = _a[1];
        return (_assign(_assign({}, accum), (_b = {}, _b[id] = value, _b)));
    }, {});
};

var removeNodeFromEvents = function (state, nodeId) {
    return Object.keys(state.events).forEach(function (key) {
        if (state.events[key] && state.events[key] === nodeId) {
            state.events[key] = null;
        }
    });
};

var Methods = function (state, query) {
    /** Helper functions */
    var addNodeToParentAtIndex = function (node, parentId, index) {
        var parent = getParentAndValidate(parentId);
        // reset the parent node ids
        if (!parent.data.nodes) {
            parent.data.nodes = [];
        }
        if (parent.data.props.children) {
            delete parent.data.props['children'];
        }
        if (index != null) {
            parent.data.nodes.splice(index, 0, node.id);
        }
        else {
            parent.data.nodes.push(node.id);
        }
        node.data.parent = parent.id;
        state.nodes[node.id] = node;
    };
    var addTreeToParentAtIndex = function (tree, parentId, index) {
        var node = tree.nodes[tree.rootNodeId];
        if (parentId != null) {
            addNodeToParentAtIndex(node, parentId, index);
        }
        if (node.data.nodes) {
            var childToAdd = __spreadArrays(node.data.nodes);
            node.data.nodes = [];
            childToAdd.forEach(function (childId, index) {
                return addTreeToParentAtIndex({ rootNodeId: childId, nodes: tree.nodes }, node.id, index);
            });
        }
        if (node.data.linkedNodes) {
            Object.keys(node.data.linkedNodes).forEach(function (linkedId) {
                var nodeId = node.data.linkedNodes[linkedId];
                state.nodes[nodeId] = tree.nodes[nodeId];
                addTreeToParentAtIndex({ rootNodeId: nodeId, nodes: tree.nodes });
            });
        }
    };
    var getParentAndValidate = function (parentId) {
        invariant__default['default'](parentId, utils.ERROR_NOPARENT);
        var parent = state.nodes[parentId];
        invariant__default['default'](parent, utils.ERROR_INVALID_NODEID);
        return parent;
    };
    var deleteNode = function (id, isLinkedNode) {
        if (isLinkedNode === void 0) { isLinkedNode = false; }
        var targetNode = state.nodes[id], parentNode = state.nodes[targetNode.data.parent];
        if (targetNode.data.nodes) {
            // we deep clone here because otherwise immer will mutate the node
            // object as we remove nodes
            __spreadArrays(targetNode.data.nodes).forEach(function (childId) { return deleteNode(childId); });
        }
        if (isLinkedNode && parentNode.data.linkedNodes) {
            var linkedId = Object.keys(parentNode.data.linkedNodes).filter(function (id) { return parentNode.data.linkedNodes[id] === id; })[0];
            if (linkedId) {
                delete parentNode.data.linkedNodes[linkedId];
            }
        }
        else {
            var parentChildren = parentNode.data.nodes;
            parentChildren.splice(parentChildren.indexOf(id), 1);
        }
        removeNodeFromEvents(state, id);
        delete state.nodes[id];
    };
    return {
        /**
         * @private
         * Add a new linked Node to the editor.
         * Only used internally by the <Element /> component
         *
         * @param tree
         * @param parentId
         * @param id
         */
        addLinkedNodeFromTree: function (tree, parentId, id) {
            var parent = getParentAndValidate(parentId);
            if (!parent.data.linkedNodes) {
                parent.data.linkedNodes = {};
            }
            var existingLinkedNode = parent.data.linkedNodes[id];
            if (existingLinkedNode) {
                deleteNode(existingLinkedNode, true);
            }
            parent.data.linkedNodes[id] = tree.rootNodeId;
            tree.nodes[tree.rootNodeId].data.parent = parentId;
            state.nodes[tree.rootNodeId] = tree.nodes[tree.rootNodeId];
            addTreeToParentAtIndex(tree);
        },
        /**
         * Add a new Node to the editor.
         *
         * @param nodeToAdd
         * @param parentId
         * @param index
         */
        add: function (nodeToAdd, parentId, index) {
            // TODO: Deprecate adding array of Nodes to keep implementation simpler
            var nodes = [nodeToAdd];
            if (Array.isArray(nodeToAdd)) {
                utils.deprecationWarning('actions.add(node: Node[])', {
                    suggest: 'actions.add(node: Node)',
                });
                nodes = nodeToAdd;
            }
            nodes.forEach(function (node) {
                addNodeToParentAtIndex(node, parentId, index);
            });
        },
        /**
         * Add a NodeTree to the editor
         *
         * @param tree
         * @param parentId
         * @param index
         */
        addNodeTree: function (tree, parentId, index) {
            var node = tree.nodes[tree.rootNodeId];
            if (!parentId) {
                invariant__default['default'](tree.rootNodeId === utils.ROOT_NODE, 'Cannot add non-root Node without a parent');
                state.nodes[tree.rootNodeId] = node;
            }
            addTreeToParentAtIndex(tree, parentId, index);
        },
        /**
         * Delete a Node
         * @param id
         */
        delete: function (id) {
            invariant__default['default'](!query.node(id).isTopLevelNode(), utils.ERROR_DELETE_TOP_LEVEL_NODE);
            deleteNode(id);
        },
        deserialize: function (input) {
            var dehydratedNodes = typeof input == 'string' ? JSON.parse(input) : input;
            var nodePairs = Object.keys(dehydratedNodes).map(function (id) {
                var nodeId = id;
                if (id === utils.DEPRECATED_ROOT_NODE) {
                    nodeId = utils.ROOT_NODE;
                }
                return [
                    nodeId,
                    query
                        .parseSerializedNode(dehydratedNodes[id])
                        .toNode(function (node) { return (node.id = nodeId); }),
                ];
            });
            this.replaceNodes(fromEntries(nodePairs));
        },
        /**
         * Move a target Node to a new Parent at a given index
         * @param targetId
         * @param newParentId
         * @param index
         */
        move: function (targetId, newParentId, index) {
            var targetNode = state.nodes[targetId], currentParentId = targetNode.data.parent, newParent = state.nodes[newParentId], newParentNodes = newParent.data.nodes;
            query.node(newParentId).isDroppable(targetNode, function (err) {
                throw new Error(err);
            });
            var currentParent = state.nodes[currentParentId], currentParentNodes = currentParent.data.nodes;
            currentParentNodes[currentParentNodes.indexOf(targetId)] = 'marked';
            newParentNodes.splice(index, 0, targetId);
            state.nodes[targetId].data.parent = newParentId;
            currentParentNodes.splice(currentParentNodes.indexOf('marked'), 1);
        },
        replaceNodes: function (nodes) {
            state.nodes = nodes;
            this.clearEvents();
        },
        clearEvents: function () {
            this.setNodeEvent('selected', null);
            this.setNodeEvent('hovered', null);
            this.setNodeEvent('dragged', null);
            this.setIndicator(null);
        },
        /**
         * Resets all the editor state.
         */
        reset: function () {
            this.clearEvents();
            this.replaceNodes({});
        },
        /**
         * Set editor options via a callback function
         *
         * @param cb: function used to set the options.
         */
        setOptions: function (cb) {
            cb(state.options);
        },
        setNodeEvent: function (eventType, id) {
            var current = state.events[eventType];
            if (current && id !== current) {
                state.nodes[current].events[eventType] = false;
            }
            if (id) {
                state.nodes[id].events[eventType] = true;
                state.events[eventType] = id;
            }
            else {
                state.events[eventType] = null;
            }
        },
        /**
         * Set custom values to a Node
         * @param id
         * @param cb
         */
        setCustom: function (id, cb) {
            cb(state.nodes[id].data.custom);
        },
        /**
         * Given a `id`, it will set the `dom` porperty of that node.
         *
         * @param id of the node we want to set
         * @param dom
         */
        setDOM: function (id, dom) {
            invariant__default['default'](state.nodes[id], utils.ERROR_INVALID_NODEID);
            state.nodes[id].dom = dom;
        },
        setIndicator: function (indicator) {
            if (indicator &&
                (!indicator.placement.parent.dom ||
                    (indicator.placement.currentNode &&
                        !indicator.placement.currentNode.dom)))
                return;
            state.events.indicator = indicator;
        },
        /**
         * Hide a Node
         * @param id
         * @param bool
         */
        setHidden: function (id, bool) {
            state.nodes[id].data.hidden = bool;
        },
        /**
         * Update the props of a Node
         * @param id
         * @param cb
         */
        setProp: function (id, cb) {
            invariant__default['default'](state.nodes[id], utils.ERROR_INVALID_NODEID);
            cb(state.nodes[id].data.props);
        },
        selectNode: function (nodeId) {
            // TODO: use ts strict-null checks
            this.setNodeEvent('selected', nodeId !== undefined && nodeId !== null ? nodeId : null);
            this.setNodeEvent('hovered', null);
        },
    };
};
var ActionMethods = function (state, query) {
    return _assign(_assign({}, Methods(state, query)), { 
        // Note: Beware: advanced method! You most likely don't need to use this
        // TODO: fix parameter types and cleanup the method
        setState: function (cb) {
            var _a = this, history = _a.history, actions = __rest(_a, ["history"]);
            // We pass the other actions as the second parameter, so that devs could still make use of the predefined actions
            cb(state, actions);
        } });
};

var resolveComponent = function (resolver, comp) {
    var Comp;
    var name = comp.name || comp.displayName;
    if (comp === Canvas)
        return 'Canvas';
    if (resolver[name])
        return name;
    for (var i = 0; i < Object.keys(resolver).length; i++) {
        var name_1 = Object.keys(resolver)[i], fn = resolver[name_1];
        if (fn === comp) {
            Comp = name_1;
            return Comp;
        }
    }
    if (typeof comp === 'string')
        return comp;
};

var reduceType = function (type, resolver) {
    if (typeof type === 'string') {
        return type;
    }
    return { resolvedName: resolveComponent(resolver, type) };
};
var serializeComp = function (data, resolver) {
    var type = data.type, isCanvas = data.isCanvas, props = data.props;
    props = Object.keys(props).reduce(function (result, key) {
        var prop = props[key];
        if (prop === undefined || prop === null) {
            return result;
        }
        if (key === 'children' && typeof prop !== 'string') {
            result[key] = React.Children.map(prop, function (child) {
                if (typeof child === 'string') {
                    return child;
                }
                return serializeComp(child, resolver);
            });
        }
        else if (prop.type) {
            result[key] = serializeComp(prop, resolver);
        }
        else {
            result[key] = prop;
        }
        return result;
    }, {});
    return {
        type: reduceType(type, resolver),
        isCanvas: !!isCanvas,
        props: props,
    };
};
var serializeNode = function (data, resolver) {
    var type = data.type, props = data.props, isCanvas = data.isCanvas, name = data.name, nodeData = __rest(data, ["type", "props", "isCanvas", "name"]);
    var reducedComp = serializeComp({ type: type, isCanvas: isCanvas, props: props }, resolver);
    return _assign(_assign({}, reducedComp), nodeData);
};

function NodeHelpers(state, id) {
    invariant__default['default'](typeof id == 'string', utils.ERROR_INVALID_NODE_ID);
    var node = state.nodes[id];
    var nodeHelpers = function (id) { return NodeHelpers(state, id); };
    var getNodeFromIdOrNode = function (node) {
        return typeof node === 'string' ? state.nodes[node] : node;
    };
    return {
        isCanvas: function () {
            return !!node.data.isCanvas;
        },
        isRoot: function () {
            return node.id === utils.ROOT_NODE;
        },
        isLinkedNode: function () {
            return (node.data.parent &&
                nodeHelpers(node.data.parent).linkedNodes().includes(node.id));
        },
        isTopLevelNode: function () {
            return this.isRoot() || this.isLinkedNode();
        },
        isDeletable: function () {
            return !this.isTopLevelNode();
        },
        isParentOfTopLevelNodes: function () {
            return node.data.linkedNodes && Object.keys(node.data.linkedNodes).length > 0;
        },
        isParentOfTopLevelCanvas: function () {
            utils.deprecationWarning('query.node(id).isParentOfTopLevelCanvas', {
                suggest: 'query.node(id).isParentOfTopLevelNodes',
            });
            return this.isParentOfTopLevelNodes();
        },
        get: function () {
            return node;
        },
        ancestors: function (deep) {
            if (deep === void 0) { deep = false; }
            function appendParentNode(id, ancestors, depth) {
                if (ancestors === void 0) { ancestors = []; }
                if (depth === void 0) { depth = 0; }
                var node = state.nodes[id];
                if (!node) {
                    return ancestors;
                }
                ancestors.push(id);
                if (!node.data.parent) {
                    return ancestors;
                }
                if (deep || (!deep && depth === 0)) {
                    ancestors = appendParentNode(node.data.parent, ancestors, depth + 1);
                }
                return ancestors;
            }
            return appendParentNode(node.data.parent);
        },
        descendants: function (deep, includeOnly) {
            if (deep === void 0) { deep = false; }
            function appendChildNode(id, descendants, depth) {
                if (descendants === void 0) { descendants = []; }
                if (depth === void 0) { depth = 0; }
                if (deep || (!deep && depth === 0)) {
                    var node_1 = state.nodes[id];
                    if (!node_1) {
                        return descendants;
                    }
                    if (includeOnly !== 'childNodes') {
                        // Include linkedNodes if any
                        var linkedNodes = nodeHelpers(id).linkedNodes();
                        linkedNodes.forEach(function (nodeId) {
                            descendants.push(nodeId);
                            descendants = appendChildNode(nodeId, descendants, depth + 1);
                        });
                    }
                    if (includeOnly !== 'linkedNodes') {
                        var childNodes = nodeHelpers(id).childNodes();
                        childNodes.forEach(function (nodeId) {
                            descendants.push(nodeId);
                            descendants = appendChildNode(nodeId, descendants, depth + 1);
                        });
                    }
                    return descendants;
                }
                return descendants;
            }
            return appendChildNode(id);
        },
        linkedNodes: function () {
            return Object.values(node.data.linkedNodes || {});
        },
        childNodes: function () {
            return node.data.nodes || [];
        },
        isDraggable: function (onError) {
            try {
                var targetNode = node;
                invariant__default['default'](!this.isTopLevelNode(), utils.ERROR_MOVE_TOP_LEVEL_NODE);
                invariant__default['default'](NodeHelpers(state, targetNode.data.parent).isCanvas(), utils.ERROR_MOVE_NONCANVAS_CHILD);
                invariant__default['default'](targetNode.rules.canDrag(targetNode, nodeHelpers), utils.ERROR_CANNOT_DRAG);
                return true;
            }
            catch (err) {
                if (onError) {
                    onError(err);
                }
                return false;
            }
        },
        isDroppable: function (target, onError) {
            var isNewNode = typeof target == 'object' && !state.nodes[target.id];
            var targetNode = getNodeFromIdOrNode(target), newParentNode = node;
            try {
                //  If target is a NodeId (thus it's already in the state), check if it's a top-level node
                if (typeof target === 'string') {
                    invariant__default['default'](!nodeHelpers(target).isTopLevelNode(), utils.ERROR_MOVE_TOP_LEVEL_NODE);
                }
                invariant__default['default'](this.isCanvas(), utils.ERROR_MOVE_TO_NONCANVAS_PARENT);
                invariant__default['default'](newParentNode.rules.canMoveIn(targetNode, newParentNode, nodeHelpers), utils.ERROR_MOVE_INCOMING_PARENT);
                invariant__default['default'](targetNode.rules.canDrop(newParentNode, targetNode, nodeHelpers), utils.ERROR_MOVE_CANNOT_DROP);
                if (isNewNode) {
                    return true;
                }
                var targetDeepNodes = nodeHelpers(targetNode.id).descendants(true);
                invariant__default['default'](!targetDeepNodes.includes(newParentNode.id) &&
                    newParentNode.id !== targetNode.id, utils.ERROR_MOVE_TO_DESCENDANT);
                var currentParentNode = targetNode.data.parent && state.nodes[targetNode.data.parent];
                invariant__default['default'](currentParentNode.data.isCanvas, utils.ERROR_MOVE_NONCANVAS_CHILD);
                invariant__default['default'](currentParentNode ||
                    (!currentParentNode && !state.nodes[targetNode.id]), utils.ERROR_DUPLICATE_NODEID);
                // If the Node we're checking for is not the same as the currentParentNode
                // Check if the currentParentNode allows the targetNode to be dragged out
                if (node !== currentParentNode) {
                    invariant__default['default'](currentParentNode.rules.canMoveOut(targetNode, currentParentNode, nodeHelpers), utils.ERROR_MOVE_OUTGOING_PARENT);
                }
                return true;
            }
            catch (err) {
                if (onError) {
                    onError(err);
                }
                return false;
            }
        },
        toSerializedNode: function () {
            return serializeNode(node.data, state.options.resolver);
        },
        toNodeTree: function (includeOnly) {
            var nodes = __spreadArrays([id], this.descendants(true, includeOnly)).reduce(function (accum, descendantId) {
                accum[descendantId] = nodeHelpers(descendantId).get();
                return accum;
            }, {});
            return {
                rootNodeId: id,
                nodes: nodes,
            };
        },
        /**
         Deprecated NodeHelpers
         **/
        decendants: function (deep) {
            if (deep === void 0) { deep = false; }
            utils.deprecationWarning('query.node(id).decendants', {
                suggest: 'query.node(id).descendants',
            });
            return this.descendants(deep);
        },
        isTopLevelCanvas: function () {
            return !this.isRoot() && !node.data.parent;
        },
    };
}

function findPosition(parent, dims, posX, posY) {
    var result = {
        parent: parent,
        index: 0,
        where: 'before',
    };
    var leftLimit = 0, xLimit = 0, dimRight = 0, yLimit = 0, xCenter = 0, yCenter = 0, dimDown = 0;
    // Each dim is: Top, Left, Height, Width
    for (var i = 0, len = dims.length; i < len; i++) {
        var dim = dims[i];
        // Right position of the element. Left + Width
        dimRight = dim.left + dim.outerWidth;
        // Bottom position of the element. Top + Height
        dimDown = dim.top + dim.outerHeight;
        // X center position of the element. Left + (Width / 2)
        xCenter = dim.left + dim.outerWidth / 2;
        // Y center position of the element. Top + (Height / 2)
        yCenter = dim.top + dim.outerHeight / 2;
        // Skip if over the limits
        if ((xLimit && dim.left > xLimit) ||
            (yLimit && yCenter >= yLimit) || // >= avoid issue with clearfixes
            (leftLimit && dimRight < leftLimit))
            continue;
        result.index = i;
        // If it's not in flow (like 'float' element)
        if (!dim.inFlow) {
            if (posY < dimDown)
                yLimit = dimDown;
            //If x lefter than center
            if (posX < xCenter) {
                xLimit = xCenter;
                result.where = 'before';
            }
            else {
                leftLimit = xCenter;
                result.where = 'after';
            }
        }
        else {
            // If y upper than center
            if (posY < yCenter) {
                result.where = 'before';
                break;
            }
            else
                result.where = 'after'; // After last element
        }
    }
    return result;
}

var getRandomNodeId = shortid__default['default'];

function createNode(newNode, normalize) {
    var actualType = newNode.data.type;
    var id = newNode.id || getRandomNodeId();
    return immer.produce({}, function (node) {
        node.id = id;
        node._hydrationTimestamp = Date.now();
        node.data = _assign({ type: actualType, props: _assign({}, newNode.data.props), name: typeof actualType == 'string' ? actualType : actualType.name, displayName: typeof actualType == 'string' ? actualType : actualType.name, custom: {}, isCanvas: false, hidden: false, nodes: [], linkedNodes: {} }, newNode.data);
        node.related = {};
        node.events = {
            selected: false,
            dragged: false,
            hovered: false,
        };
        node.rules = _assign({ canDrag: function () { return true; }, canDrop: function () { return true; }, canMoveIn: function () { return true; }, canMoveOut: function () { return true; } }, ((actualType.craft && actualType.craft.rules) || {}));
        // @ts-ignore
        if (node.data.type === Element || node.data.type === Canvas) {
            var usingDeprecatedCanvas = node.data.type === Canvas;
            var mergedProps_1 = _assign(_assign({}, defaultElementProps), node.data.props);
            Object.keys(defaultElementProps).forEach(function (key) {
                node.data[elementPropToNodeData[key] || key] = mergedProps_1[key];
                delete node.data.props[key];
            });
            actualType = node.data.type;
            if (usingDeprecatedCanvas) {
                node.data.isCanvas = true;
                deprecateCanvasComponent();
            }
        }
        if (normalize) {
            normalize(node);
        }
        if (actualType.craft) {
            node.data.props = _assign(_assign({}, (actualType.craft.props || actualType.craft.defaultProps || {})), node.data.props);
            var displayName = actualType.craft.displayName || actualType.craft.name;
            if (displayName) {
                node.data.displayName = displayName;
            }
            if (actualType.craft.isCanvas) {
                node.data.isCanvas = node.data.isCanvas || actualType.craft.isCanvas;
            }
            if (actualType.craft.rules) {
                Object.keys(actualType.craft.rules).forEach(function (key) {
                    if (['canDrag', 'canDrop', 'canMoveIn', 'canMoveOut'].includes(key)) {
                        node.rules[key] = actualType.craft.rules[key];
                    }
                });
            }
            if (actualType.craft.custom) {
                node.data.custom = _assign(_assign({}, actualType.craft.custom), node.data.custom);
            }
            if (actualType.craft.related) {
                node.related = {};
                var relatedNodeContext_1 = {
                    id: node.id,
                    related: true,
                };
                Object.keys(actualType.craft.related).forEach(function (comp) {
                    node.related[comp] = function () {
                        return React__default['default'].createElement(NodeProvider, relatedNodeContext_1, React__default['default'].createElement(actualType.craft.related[comp]));
                    };
                });
            }
        }
    });
}

var restoreType = function (type, resolver) {
    return typeof type === 'object' && type.resolvedName
        ? type.resolvedName === 'Canvas'
            ? Canvas
            : resolver[type.resolvedName]
        : typeof type === 'string'
            ? type
            : null;
};
var deserializeComp = function (data, resolver, index) {
    var type = data.type, props = data.props;
    var main = restoreType(type, resolver);
    if (!main) {
        return;
    }
    props = Object.keys(props).reduce(function (result, key) {
        var prop = props[key];
        if (prop === null || prop === undefined) {
            result[key] = null;
        }
        else if (typeof prop === 'object' && prop.resolvedName) {
            result[key] = deserializeComp(prop, resolver);
        }
        else if (key === 'children' && Array.isArray(prop)) {
            result[key] = prop.map(function (child) {
                if (typeof child === 'string') {
                    return child;
                }
                return deserializeComp(child, resolver);
            });
        }
        else {
            result[key] = prop;
        }
        return result;
    }, {});
    if (index) {
        props.key = index;
    }
    var jsx = _assign({}, React__default['default'].createElement(main, _assign({}, props)));
    return _assign(_assign({}, jsx), { name: resolveComponent(resolver, jsx.type) });
};
var deserializeNode = function (data, resolver) {
    var Comp = data.type, Props = data.props, nodeData = __rest(data, ["type", "props"]);
    var isCompAnHtmlElement = Comp !== undefined && typeof Comp === 'string';
    var isCompAUserComponent = Comp !== undefined &&
        Comp.resolvedName !== undefined;
    invariant__default['default'](isCompAnHtmlElement || isCompAUserComponent, utils.ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER.replace('%displayName%', data.displayName).replace('%availableComponents%', Object.keys(resolver).join(', ')));
    var _a = deserializeComp(data, resolver), type = _a.type, name = _a.name, props = _a.props;
    var parent = nodeData.parent, custom = nodeData.custom, displayName = nodeData.displayName, isCanvas = nodeData.isCanvas, nodes = nodeData.nodes, hidden = nodeData.hidden;
    var linkedNodes = nodeData.linkedNodes || nodeData._childCanvas;
    return {
        type: type,
        name: name,
        displayName: displayName || name,
        props: props,
        custom: custom || {},
        isCanvas: !!isCanvas,
        hidden: !!hidden,
        parent: parent,
        linkedNodes: linkedNodes || {},
        nodes: nodes || [],
    };
};

var mergeNodes = function (rootNode, childrenNodes) {
    var _a, _b;
    if (childrenNodes.length < 1) {
        return _a = {}, _a[rootNode.id] = rootNode, _a;
    }
    var nodes = childrenNodes.map(function (_a) {
        var rootNodeId = _a.rootNodeId;
        return rootNodeId;
    });
    var nodeWithChildren = _assign(_assign({}, rootNode), { data: _assign(_assign({}, rootNode.data), { nodes: nodes }) });
    var rootNodes = (_b = {}, _b[rootNode.id] = nodeWithChildren, _b);
    return childrenNodes.reduce(function (accum, tree) {
        var _a;
        var currentNode = tree.nodes[tree.rootNodeId];
        return _assign(_assign(_assign({}, accum), tree.nodes), (_a = {}, _a[currentNode.id] = _assign(_assign({}, currentNode), { data: _assign(_assign({}, currentNode.data), { parent: rootNode.id }) }), _a));
    }, rootNodes);
};
var mergeTrees = function (rootNode, childrenNodes) { return ({
    rootNodeId: rootNode.id,
    nodes: mergeNodes(rootNode, childrenNodes),
}); };

function parseNodeFromJSX(jsx, normalize) {
    var element = jsx;
    if (typeof element === 'string') {
        element = React__default['default'].createElement(React.Fragment, {}, element);
    }
    var actualType = element.type;
    return createNode({
        data: {
            type: actualType,
            props: _assign({}, element.props),
        },
    }, function (node) {
        if (normalize) {
            normalize(node, element);
        }
    });
}

function QueryMethods(state) {
    var options = state && state.options;
    var _ = function () {
        return QueryMethods(state);
    };
    return {
        /**
         * Determine the best possible location to drop the source Node relative to the target Node
         */
        getDropPlaceholder: function (source, target, pos, nodesToDOM) {
            if (nodesToDOM === void 0) { nodesToDOM = function (node) {
                return state.nodes[node.id].dom;
            }; }
            if (source === target)
                return;
            var sourceNodeFromId = typeof source == 'string' && state.nodes[source], targetNode = state.nodes[target], isTargetCanvas = _().node(targetNode.id).isCanvas();
            var targetParent = isTargetCanvas
                ? targetNode
                : state.nodes[targetNode.data.parent];
            if (!targetParent)
                return;
            var targetParentNodes = targetParent.data.nodes || [];
            var dimensionsInContainer = targetParentNodes
                ? targetParentNodes.reduce(function (result, id) {
                    var dom = nodesToDOM(state.nodes[id]);
                    if (dom) {
                        var info = _assign({ id: id }, utils.getDOMInfo(dom));
                        result.push(info);
                    }
                    return result;
                }, [])
                : [];
            var dropAction = findPosition(targetParent, dimensionsInContainer, pos.x, pos.y);
            var currentNode = targetParentNodes.length &&
                state.nodes[targetParentNodes[dropAction.index]];
            var output = {
                placement: _assign(_assign({}, dropAction), { currentNode: currentNode }),
                error: false,
            };
            // If source Node is already in the editor, check if it's draggable
            if (sourceNodeFromId) {
                _()
                    .node(sourceNodeFromId.id)
                    .isDraggable(function (err) { return (output.error = err); });
            }
            // Check if source Node is droppable in target
            _()
                .node(targetParent.id)
                .isDroppable(source, function (err) { return (output.error = err); });
            return output;
        },
        /**
         * Get the current Editor options
         */
        getOptions: function () {
            return options;
        },
        /**
         * Helper methods to describe the specified Node
         * @param id
         */
        node: function (id) {
            return NodeHelpers(state, id);
        },
        /**
         * Returns all the `nodes` in a serialized format
         */
        getSerializedNodes: function () {
            var _this = this;
            var nodePairs = Object.keys(state.nodes).map(function (id) { return [
                id,
                _this.node(id).toSerializedNode(),
            ]; });
            return fromEntries(nodePairs);
        },
        /**
         * Retrieve the JSON representation of the editor's Nodes
         */
        serialize: function () {
            return JSON.stringify(this.getSerializedNodes());
        },
        parseReactElement: function (reactElement) { return ({
            toNodeTree: function (normalize) {
                var node = parseNodeFromJSX(reactElement, function (node, jsx) {
                    var name = resolveComponent(state.options.resolver, node.data.type);
                    invariant__default['default'](name !== null, utils.ERROR_NOT_IN_RESOLVER);
                    node.data.displayName = node.data.displayName || name;
                    node.data.name = name;
                    if (normalize) {
                        normalize(node, jsx);
                    }
                });
                var childrenNodes = [];
                if (reactElement.props && reactElement.props.children) {
                    childrenNodes = React__default['default'].Children.toArray(reactElement.props.children).reduce(function (accum, child) {
                        if (React__default['default'].isValidElement(child)) {
                            accum.push(_().parseReactElement(child).toNodeTree(normalize));
                        }
                        return accum;
                    }, []);
                }
                return mergeTrees(node, childrenNodes);
            },
        }); },
        parseSerializedNode: function (serializedNode) { return ({
            toNode: function (normalize) {
                var data = deserializeNode(serializedNode, state.options.resolver);
                invariant__default['default'](data.type, utils.ERROR_NOT_IN_RESOLVER);
                var id = typeof normalize === 'string' && normalize;
                if (id) {
                    utils.deprecationWarning("query.parseSerializedNode(...).toNode(id)", {
                        suggest: "query.parseSerializedNode(...).toNode(node => node.id = id)",
                    });
                }
                return _()
                    .parseFreshNode(_assign(_assign({}, (id ? { id: id } : {})), { data: data }))
                    .toNode(!id && normalize);
            },
        }); },
        parseFreshNode: function (node) { return ({
            toNode: function (normalize) {
                return createNode(node, function (node) {
                    if (node.data.parent === utils.DEPRECATED_ROOT_NODE) {
                        node.data.parent = utils.ROOT_NODE;
                    }
                    var name = resolveComponent(state.options.resolver, node.data.type);
                    invariant__default['default'](name !== null, utils.ERROR_NOT_IN_RESOLVER);
                    node.data.displayName = node.data.displayName || name;
                    node.data.name = name;
                    if (normalize) {
                        normalize(node);
                    }
                });
            },
        }); },
        createNode: function (reactElement, extras) {
            utils.deprecationWarning("query.createNode(" + reactElement + ")", {
                suggest: "query.parseReactElement(" + reactElement + ").toNodeTree()",
            });
            var tree = this.parseReactElement(reactElement).toNodeTree();
            var node = tree.nodes[tree.rootNodeId];
            if (!extras) {
                return node;
            }
            if (extras.id) {
                node.id = extras.id;
            }
            if (extras.data) {
                node.data = _assign(_assign({}, node.data), extras.data);
            }
            return node;
        },
        getState: function () {
            return state;
        },
    };
}

var editorInitialState = {
    nodes: {},
    events: {
        dragged: null,
        selected: null,
        hovered: null,
        indicator: null,
    },
    handlers: null,
    options: {
        onNodesChange: function () { return null; },
        onRender: function (_a) {
            var render = _a.render;
            return render;
        },
        resolver: {},
        enabled: true,
        indicator: {
            error: 'red',
            success: 'rgb(98, 196, 98)',
        },
        handlers: function (store) { return new DefaultEventHandlers(store); },
    },
};
var ActionMethodsWithConfig = {
    methods: ActionMethods,
    ignoreHistoryForActions: [
        'setDOM',
        'setNodeEvent',
        'selectNode',
        'clearEvents',
        'setOptions',
        'setIndicator',
    ],
    normalizeHistory: function (state) {
        // TODO(prev): this should be handled by the general normalising function
        /**
         * On every undo/redo, we remove events pointing to deleted Nodes
         */
        Object.keys(state.events).forEach(function (eventName) {
            var nodeId = state.events[eventName];
            if (!!nodeId && !state.nodes[nodeId]) {
                state.events[eventName] = false;
            }
        });
        // Remove any invalid node[nodeId].events
        // TODO(prev): it's really cumbersome to have to ensure state.events and state.nodes[nodeId].events are in sync
        // Find a way to make it so that once state.events is set, state.nodes[nodeId] automatically reflects that (maybe using proxies?)
        Object.keys(state.nodes).forEach(function (id) {
            var node = state.nodes[id];
            Object.keys(node.events).forEach(function (eventName) {
                var isEventActive = node.events[eventName];
                if (!!isEventActive && !state.events[eventName] !== node.id) {
                    node.events[eventName] = false;
                }
            });
        });
    },
};
var useEditorStore = function (options) {
    return utils.useMethods(ActionMethodsWithConfig, _assign(_assign({}, editorInitialState), { options: _assign(_assign({}, editorInitialState.options), options) }), QueryMethods);
};

/**
 * A React Component that provides the Editor context
 */
var Editor = function (_a) {
    var children = _a.children, options = __rest(_a, ["children"]);
    // we do not want to warn the user if no resolver was supplied
    if (options.resolver !== undefined) {
        invariant__default['default'](typeof options.resolver === 'object' && !Array.isArray(options.resolver), utils.ERROR_RESOLVER_NOT_AN_OBJECT);
    }
    var context = useEditorStore(options);
    React.useEffect(function () {
        if (context && options)
            context.actions.setOptions(function (editorOptions) {
            });
    }, [context, options]);
    React.useEffect(function () {
        context.subscribe(function (_) { return ({
            json: context.query.serialize(),
        }); }, function () {
            context.query.getOptions().onNodesChange(context.query);
        });
    }, [context]);
    return context ? (React__default['default'].createElement(EditorContext.Provider, { value: context },
        React__default['default'].createElement(Events, null, children))) : null;
};

Object.defineProperty(exports, 'ROOT_NODE', {
    enumerable: true,
    get: function () {
        return utils.ROOT_NODE;
    }
});
exports.ActionMethodsWithConfig = ActionMethodsWithConfig;
exports.Canvas = Canvas;
exports.CoreEventHandlers = CoreEventHandlers;
exports.DefaultEventHandlers = DefaultEventHandlers;
exports.DerivedEventHandlers = DerivedEventHandlers;
exports.Editor = Editor;
exports.Element = Element;
exports.Events = Events;
exports.Frame = Frame;
exports.Handlers = Handlers;
exports.NodeContext = NodeContext;
exports.NodeProvider = NodeProvider;
exports.connectEditor = connectEditor;
exports.connectNode = connectNode;
exports.defaultElementProps = defaultElementProps;
exports.defineEventListener = defineEventListener;
exports.deprecateCanvasComponent = deprecateCanvasComponent;
exports.editorInitialState = editorInitialState;
exports.elementPropToNodeData = elementPropToNodeData;
exports.useEditor = useEditor;
exports.useEditorStore = useEditorStore;
exports.useEventHandler = useEventHandler;
exports.useNode = useNode;
